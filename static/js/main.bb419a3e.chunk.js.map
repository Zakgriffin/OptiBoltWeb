{"version":3,"sources":["App.jsx","useScript.ts","screw/display.ts","screw/constants.ts","screw/screwInfo.ts","screw/cleaner.ts","screw/optiBolt.ts","serviceWorker.ts","index.tsx"],"names":["videoConstraints","width","height","facingMode","WebcamCapture","useScript","loaded","webcamRef","useRef","canvasRef","useEffect","cv","global","video","document","getElementById","cap","VideoCapture","setInterval","Mat","frame","CV_8UC4","read","optiBolt","ref","id","audio","screenshotFormat","cachedScripts","src","useState","error","state","setState","includes","push","script","createElement","async","onScriptLoad","onScriptError","index","indexOf","splice","remove","addEventListener","body","appendChild","removeEventListener","xB","yB","wB","hB","pixelsPerInch","minSize","screwHeadTolerance","peakTolerance","screwLengths","screwDiameters","screwThreads","13","17","15","19","pad","Object","keys","map","k","parseFloat","outline","topLeft","bottomRight","lineColor","thickness","lineType","cornerRadius","tlx","x","tly","y","brx","bry","p1","p2","p3","p4","line","roundRect","Scalar","labelAllInfo","length","diameter","thread","dimensions","descriptor","coord","color","whole","num","den","putText","FONT_HERSHEY_SIMPLEX","toString","labelMeasure","max","Math","floor","left","abs","round","imperialFrac","text","start","labelMeasureSimple","getLength","tops","bottoms","half","getDiameter","averageHeight","average","p","getThreadCount","amp","heading","peaks","t","b","cleanPoints","screw","data32F","dx","dy","A","atan2","flatPoints","points","point","xRel","yRel","r","sqrt","aOff","xNew","cos","yNew","sin","extra","onTops","crossed","concat","highest","reverse","removeHead","i","slice","mask","cvtColor","COLOR_RGBA2GRAY","threshold","THRESH_BINARY_INV","contours","MatVector","hierarchy","findContours","RETR_EXTERNAL","CHAIN_APPROX_SIMPLE","screws","size","ctr","get","box","boundingRect","j","rows","data32S","fitLine","DIST_L2","circle","threadCount","dp","imshow","delete","Boolean","window","location","hostname","match","ReactDOM","render","App","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.bb419a3e.chunk.js","sourcesContent":["import React, { useEffect, useRef } from 'react'\r\nimport Webcam from 'react-webcam'\r\nimport useScript from './useScript'\r\nimport optiBolt from './screw/optiBolt'\r\n\r\nconst videoConstraints = {\r\n    width: 500,\r\n    height: 200,\r\n    facingMode: 'user'\r\n}\r\n\r\nexport default function WebcamCapture() {\r\n    const [loaded] = useScript('opencv.js')\r\n\r\n    const webcamRef = useRef()\r\n    const canvasRef = useRef()\r\n\r\n    useEffect(() => {\r\n        if(!loaded) return\r\n\r\n        const cv = global.cv\r\n\r\n        let video = document.getElementById('video')\r\n        let cap = new cv.VideoCapture(video)\r\n\r\n        setInterval(() => {\r\n            if(!cv.Mat) return\r\n            let frame = new cv.Mat(video.height, video.width, cv.CV_8UC4)\r\n            cap.read(frame)\r\n        \r\n            //let newFrame = new cv.Mat()\r\n            /*let newFrame = */optiBolt(cv, frame)\r\n            \r\n            //cv.cvtColor(frame, newFrame, cv.COLOR_RGBA2GRAY, 0)\r\n            //cv.imshow(canvasRef.current, newFrame)\r\n\r\n            //frame.delete()\r\n            //newFrame.delete()\r\n        }, 100)\r\n    }, [loaded])\r\n  \r\n    return <>\r\n        <canvas ref={canvasRef} id='canvasOutput'/>\r\n        <canvas  id='canvasOutput2'/>\r\n        <Webcam id='video'\r\n            audio={false}\r\n            height={720}\r\n            ref={webcamRef}\r\n            screenshotFormat='image/jpeg'\r\n            width={1280}\r\n            videoConstraints={videoConstraints}\r\n        />\r\n    </>\r\n}","import {useState, useEffect} from 'react'\r\n\r\nlet cachedScripts: string[] = []\r\nexport default function useScript(src: string) {\r\n  // Keeping track of script loaded and error state\r\n  const [state, setState] = useState({\r\n    loaded: false,\r\n    error: false\r\n  })\r\n\r\n  useEffect(\r\n    () => {\r\n      // If cachedScripts array already includes src that means another instance ...\r\n      // ... of this hook already loaded this script, so no need to load again.\r\n      if (cachedScripts.includes(src)) {\r\n        setState({\r\n          loaded: true,\r\n          error: false\r\n        })\r\n      } else {\r\n        cachedScripts.push(src)\r\n\r\n        // Create script\r\n        let script = document.createElement('script')\r\n        script.src = src\r\n        script.async = true\r\n\r\n        // Script event listener callbacks for load and error\r\n        const onScriptLoad = () => {\r\n          setState({\r\n            loaded: true,\r\n            error: false\r\n          })\r\n        }\r\n\r\n        const onScriptError = () => {\r\n          // Remove from cachedScripts we can try loading again\r\n          const index = cachedScripts.indexOf(src)\r\n          if (index >= 0) cachedScripts.splice(index, 1)\r\n          script.remove()\r\n\r\n          setState({\r\n            loaded: true,\r\n            error: true\r\n          })\r\n        }\r\n\r\n        script.addEventListener('load', onScriptLoad)\r\n        script.addEventListener('error', onScriptError)\r\n\r\n        // Add script to document body\r\n        document.body.appendChild(script)\r\n\r\n        // Remove event listeners on cleanup\r\n        return () => {\r\n          script.removeEventListener('load', onScriptLoad)\r\n          script.removeEventListener('error', onScriptError)\r\n        }\r\n      }\r\n    },\r\n    [src] // Only re-run effect if script src changes\r\n  )\r\n\r\n  return [state.loaded, state.error]\r\n}","// Functions for displaying retrieved measurements in a human readable way\r\n\r\nimport {screwLengths, screwDiameters, screwThreads} from './constants'\r\nimport {Mat, Box, ScrewDimensions, Point, ScrewPresetList} from './types'\r\n\r\nconst lengthKeys = Object.keys(screwLengths).map(k => parseFloat(k))\r\nconst diameterKeys = Object.keys(screwDiameters).map(k => parseFloat(k))\r\nconst threadKeys = Object.keys(screwThreads).map(k => parseFloat(k))\r\n\r\nconst pad = 10\r\nlet frame: Mat\r\nlet xB: number, yB: number, wB: number, hB: number\r\n\r\nlet cv: any\r\nexport function setCV(c: any) {cv = c}\r\n\r\nexport function setFrame(f: Mat) {\r\n    // Sets the frame for drawing images\r\n    frame = f\r\n}\r\n\r\nexport function setBox(b: Box) {\r\n    // Sets coords for box outline\r\n    xB = b.x\r\n    yB = b.y\r\n    wB = b.width\r\n    hB = b.height\r\n}\r\n\r\nexport function labelMeasure(dimensions: ScrewDimensions, descriptor = '',\r\n        coord: Point = {x: 0, y: 0}, color = new cv.Scalar(255, 255, 255)) {\r\n    // Labels fractional measurements on frame\r\n    let {whole, num, den} = dimensions\r\n    let {x, y} = coord\r\n\r\n    cv.putText(frame, whole + ' in', {x, y}, cv.FONT_HERSHEY_SIMPLEX, 1, color, 1) // whole\r\n    cv.putText(frame, num.toString(), {x: x + 20, y: y - 15}, cv.FONT_HERSHEY_SIMPLEX, 0.4, color, 1) // numerator\r\n    cv.putText(frame, den.toString(), {x: x + 20, y}, cv.FONT_HERSHEY_SIMPLEX, 0.4, color, 1) // denominator\r\n    cv.putText(frame, descriptor, {x: x + 65, y}, cv.FONT_HERSHEY_SIMPLEX, 0.3, color, 1) // descriptor\r\n\r\n    cv.line(frame, {x: x + 20, y: y - 12}, {x: x + 35, y: y - 12}, color, 1) // fraction bar\r\n}\r\n\r\nexport function labelMeasureSimple(text: string, descriptor = '',\r\n        start: Point = {x: 0, y: 0}, color = new cv.Scalar(255, 255, 255)) {\r\n    // Labels simple measurements on frame\r\n    let {x, y} = start\r\n    cv.putText(frame, text, {x, y}, cv.FONT_HERSHEY_SIMPLEX, 1, color, 1)\r\n    cv.putText(frame, descriptor, {x: x + 65, y}, cv.FONT_HERSHEY_SIMPLEX, 0.3, color, 1) // descriptor\r\n}\r\n\r\nexport function outline() {\r\n    // Outlines screw with round rectangle\r\n    roundRect(frame, {x: xB - pad, y: yB - pad}, {x: xB + wB + pad, y: yB + hB + pad},\r\n        new cv.Scalar(255, 255, 255), 2, 8, 10)\r\n}\r\n    \r\n\r\nexport function labelAllInfo(length: number, diameter: number, thread: number) {\r\n    // Labels all information about a screw (length, diameter, thread) on frame\r\n    //labelMeasure(imperialFrac(length), 'Length', {x: xB + wB + 15, y: yB})\r\n    labelMeasure(imperialFrac(diameter), 'Diam', {x: xB + wB + 15, y: yB + 35})\r\n    labelMeasureSimple(thread.toString(), 'Threads', {x: xB + wB + 15, y: yB + 70},\r\n        new cv.Scalar(255, 255, 255))\r\n}\r\n\r\nexport function quickColorInfo(length: number, diameter: number, thread: number) {\r\n    // Marks screw with color indicators for easy human sorting\r\n    function getClosest(val: number, screwList: ScrewPresetList, keysList: number[]) {\r\n        return screwList[keysList.reduce((accum, curr) =>\r\n            Math.abs(accum - val) < Math.abs(curr - val) ? accum : curr\r\n        )]\r\n    }\r\n    let lengthColor = getClosest(length, screwLengths, lengthKeys)\r\n    let diamColor = getClosest(diameter, screwDiameters, diameterKeys)\r\n    let threadColor = getClosest(thread, screwThreads, threadKeys)\r\n\r\n    let iSize = 6 // size of an indicator square\r\n    let xI = xB + wB + pad\r\n    let yI = yB + hB // 2\r\n    cv.rectangle(frame, {x: xI - iSize, y: yI - 3 * iSize},\r\n        {x: xI + iSize, y: yI - iSize}, lengthColor, cv.FILLED)\r\n    cv.rectangle(frame, {x: xI - iSize, y: yI - iSize},\r\n        {x: xI + iSize, y: yI + iSize}, diamColor, cv.FILLED)\r\n    cv.rectangle(frame, {x: xI - iSize, y: yI + iSize},\r\n        {x: xI + iSize, y: yI + 3 * iSize}, threadColor, cv.FILLED)\r\n\r\n    cv.rectangle(frame, {x: xI - iSize, y: yI - 3 * iSize},\r\n        {x: xI + iSize, y: yI + 3 * iSize}, new cv.Scalar(255, 255, 255), 1)\r\n}\r\n\r\nfunction roundRect(frame: Mat, topLeft: Point, bottomRight: Point, lineColor: any,\r\n        thickness: number, lineType: any, cornerRadius: number) {\r\n    // Draws a rect with rounded corners\r\n    /*\r\n    corners:\r\n    p1 - p2\r\n    |     |\r\n    p4 - p3\r\n    */\r\n    let tlx = topLeft.x\r\n    let tly = topLeft.y\r\n    let brx = bottomRight.x\r\n    let bry = bottomRight.y\r\n\r\n    let p1 = {x: tlx, y: tly}\r\n    let p2 = {x: brx, y: tly}\r\n    let p3 = {x: brx, y: bry}\r\n    let p4 = {x: tlx, y: bry}\r\n\r\n    // draw straight lines\r\n    cv.line(frame, {x: p1.x + cornerRadius, y: p1.y}, {x: p2.x - cornerRadius, y: p2.y}, lineColor, thickness, lineType)\r\n    cv.line(frame, {x: p2.x, y: p2.y + cornerRadius}, {x: p3.x, y: p3.y - cornerRadius}, lineColor, thickness, lineType)\r\n    cv.line(frame, {x: p4.x + cornerRadius, y: p4.y}, {x: p3.x - cornerRadius, y: p3.y}, lineColor, thickness, lineType)\r\n    cv.line(frame, {x: p1.x, y: p1.y + cornerRadius}, {x: p4.x, y: p4.y - cornerRadius}, lineColor, thickness, lineType)\r\n\r\n    // draw arcs\r\n    //cv.ellipse(frame, {x: p1.x + cornerRadius, y: p1.y + cornerRadius}, {x: cornerRadius, y: cornerRadius}, 180, 0, 90, lineColor, thickness, lineType)\r\n    //cv.ellipse(frame, {x: p2.x - cornerRadius, y: p2.y + cornerRadius}, {x: cornerRadius, y: cornerRadius}, 270, 0, 90, lineColor, thickness, lineType)\r\n    //cv.ellipse(frame, {x: p3.x - cornerRadius, y: p3.y - cornerRadius}, {x: cornerRadius, y: cornerRadius}, 0.0, 0, 90, lineColor, thickness, lineType)\r\n    //cv.ellipse(frame, {x: p4.x + cornerRadius, y: p4.y - cornerRadius}, {x: cornerRadius, y: cornerRadius}, 90, 0, 90, lineColor, thickness, lineType)\r\n    // DEBUG ^\r\n}\r\n\r\nfunction imperialFrac(x: number, max: number = 32) {\r\n    // Converts decimal into 3 part tuple for fractional imperial measurement\r\n    if(x < 0) return {whole: 0, num: 0, den: 1}//throw new Error('x must be >= 0')\r\n    \r\n    let whole = Math.floor(x)\r\n    let left = x - whole\r\n    let den = 2\r\n\r\n    while(Math.abs(Math.round(left * den) - left * den) > 0.1 && den !== max) {\r\n        den *= 2\r\n    }\r\n    let num = Math.round(left * den)\r\n\r\n    return {whole, num, den}\r\n}","// Constants used for various purposes\r\nexport const pixelsPerInch = 144 // pixels per inch\r\nexport const minSize = 0.3 * pixelsPerInch // minimum area a \"screw\" can be without being ignored\r\nexport const screwHeadTolerance = 0.1 * pixelsPerInch // tolerance for discounting screw head points\r\nexport const peakTolerance = 0.7 // tolerance for discounting noise in peak recognition\r\n\r\n// Identifiable Screw Measurements [for estimating and color indicators]\r\nexport const screwLengths = {\r\n    [3/8]: [0, 0, 255], // tiny boi -> red\r\n    [5/8]: [0, 255, 0], // normal boi -> green\r\n    [3/4]: [255, 0, 0], // funky boi -> blue\r\n    [1/1]: [255, 0, 255], // smol wood boi -> purple\r\n    [2 + 1/4]: [255, 255, 0] // absolute lad - > cyan\r\n} \r\n\r\nexport const screwDiameters = {\r\n    [3/16]: [0, 0, 255], // normal-ish chonk -> red\r\n    [1/8]: [255, 0, 0] // thin wood -> blue\r\n}\r\n\r\nexport const screwThreads = {\r\n    13: [0, 0, 255], // tiny boi -> red\r\n    17: [0, 255, 0], // normal boi AND funky boi -> green\r\n    15: [255, 0, 255], // smol wood boi -> purple\r\n    19: [255, 255, 0] // absolute lad - > cyan\r\n}","// Functions for pulling quantitative values from a cleaned set of points\r\nimport {pixelsPerInch, peakTolerance} from './constants'\r\n\r\nimport {ScrewHalf, Point} from './types'\r\n\r\nfunction getLength(tops: ScrewHalf, bottoms: ScrewHalf) {\r\n    // Returns estimated length of screw\r\n    function length(half: ScrewHalf) {\r\n        return half[half.length - 1].x - half[0].x\r\n    }\r\n    return ((length(tops) + length(bottoms)) / 2) / pixelsPerInch\r\n}\r\n\r\nfunction getDiameter(tops: ScrewHalf, bottoms: ScrewHalf) {\r\n    // Returns estimated diameter of screw\r\n    function averageHeight(half: ScrewHalf) {\r\n        let average = 0\r\n        half.map(p => average += p.y)\r\n        return average / half.length\r\n    }\r\n    return (averageHeight(tops) + averageHeight(bottoms)) / pixelsPerInch\r\n}\r\n\r\nfunction getThreadCount(tops: ScrewHalf, bottoms: ScrewHalf): number {\r\n    // Returns estimated thread count of screw\r\n    function thread(half: ScrewHalf) {\r\n        let k: Point[] = [] // DEBUG - for seeing some important points\r\n\r\n        let amp = 0 // keeps track of most extreme recent amplitude\r\n        let heading = false // boolean that alternates when a peak or valley is reached\r\n        let peaks = 0\r\n        for(let p of half) {\r\n            let height = p.y // get y coord of p\r\n            if((heading && (height - peakTolerance > amp)) || ((!heading && (height + peakTolerance < amp)))) {\r\n                // reached either a peak or valley\r\n                if(heading) {\r\n                    peaks++\r\n                    k.push(p) // peak\r\n                }\r\n                heading = !heading // invert heading boolean, going from peaks, to valleys, or vise versa\r\n            } else {\r\n                // not a peak of valley, continue searching\r\n                amp = height\r\n            }\r\n        }\r\n        return peaks\r\n    }\r\n    let t = thread(tops)\r\n    let b = thread(bottoms)\r\n    return Math.round((t + b) / 2)\r\n}\r\n\r\nexport {getLength, getDiameter, getThreadCount}","// Contains function for cleaning contour points for later processing\r\nimport {screwHeadTolerance} from './constants'\r\nimport {Mat, Screw, Point, ScrewHalf} from './types'\r\n\r\nexport function cleanPoints(screw: Screw, frame: Mat): [ScrewHalf | null, ScrewHalf | null] {\r\n    // Function Outline:\r\n    // 1. Rotate all points of screw by opposite the angle of line of best fit (rotate points to have screw laying horizontally)\r\n    // 2. Assign each point to tops or bottoms lists, splitting screw in half\r\n    // 3. Flip x and y for necessary points so that screw head is on the right\r\n    // 4. Reverse order of necessary lists so that first element is farthest left\r\n    // 5. Find extraneous points to remove head of screw\r\n    // 6. Return tuple of cleaned tops and bottoms\r\n\r\n    let [dx, dy, x, y] = screw.line.data32F // unpack line best fit dy/dx, center at (x, y)\r\n    let A = Math.atan2(dy, dx) // rotate all points by this angle\r\n\r\n    //cv2.line(frame, (x, y), (20 * Math.cos(A) + x, 20 * Math.sin(A) + y), (255, 0, 255), 2) // DEBUG\r\n    //cv2.circle(frame, (x, y), 3, (0, 0, 255), -1) // DEBUG\r\n\r\n    let flatPoints: ScrewHalf = []\r\n    // 1. Rotate all points of screw by opposite the angle of line of best fit\r\n    for(let point of screw.points) {\r\n        // coords relative to center of screw at (x, y)\r\n        let xRel = x - point.x\r\n        let yRel = y - point.y\r\n\r\n        let r = Math.sqrt(xRel * xRel + yRel * yRel) // distance to point\r\n        let aOff = Math.atan2(yRel, xRel) // angle to point\r\n        \r\n        // new rotated coords\r\n        let xNew = r * Math.cos(aOff - A)\r\n        let yNew = r * Math.sin(aOff - A)\r\n\r\n        flatPoints.push({x: xNew, y: yNew}) // add to list\r\n    }\r\n\r\n    // 2. Assign each point to tops or bottoms lists, splitting screw in half\r\n    let tops: ScrewHalf = []\r\n    let bottoms: ScrewHalf = []\r\n    let extra: Point[] = [] // to be appended to beginning of either tops or bottoms\r\n\r\n    let onTops = flatPoints[0].y < 0 // whether or not on tops\r\n    let crossed = 0 // counts number of times crossed\r\n    for(let p of flatPoints) {\r\n        if((p.y < 0) !== onTops) {\r\n            // crossed\r\n            crossed++\r\n            onTops = !onTops\r\n        }\r\n        if(crossed >= 2) {\r\n            extra.push(p)\r\n        } else if(p.y < 0) {\r\n            tops.push(p)\r\n        } else {\r\n            bottoms.push(p)\r\n        }\r\n    }\r\n    // merge extra list with correct half in order\r\n    if(onTops) tops = extra.concat(tops)\r\n    else bottoms = extra.concat(bottoms)\r\n\r\n    // now for the tricky bit...\r\n\r\n    // find if highest point is to the left or right of center\r\n    let highest = {x: 0, y: 0} // coord of heighest point (on head of screw)\r\n    for(let p of bottoms) {\r\n        if(p.y > highest.y) highest = p // found new highest\r\n    }\r\n    // 3. Flip x and y for necessary points so that screw head is on the right\r\n\r\n    // y coords\r\n    for(let p of tops) p.y = -p.y // always have to negate y coord of all in tops\r\n    // never have to negate y coord of all in bottoms\r\n\r\n    // x coords\r\n    if(highest.x < 0) {\r\n        // screw head was on left\r\n        for(let p of tops) p.x = -p.x // negate x coord of all in tops\r\n        for(let p of bottoms) p.x = -p.x // negate x coord of all in bottoms\r\n        \r\n    // 4. Reverse order of necessary lists so that first element is farthest left\r\n        bottoms.reverse() // reverse list of bottoms\r\n    } else {\r\n        // screw head is on right\r\n        tops.reverse() // reverse list of tops\r\n    }\r\n\r\n    // 5. Find extraneous points to remove head of screw\r\n    const removeHead = (half: ScrewHalf) => {\r\n        // sub function applied to tops and bottoms\r\n        let average = 0\r\n        if(half.length === 0) return []\r\n\r\n        for(let p of half) average += p.y\r\n        average /= half.length // average is now roughly radius of screw\r\n\r\n        //cv2.line(frame, (0, average + y), (1000, average + y), (255, 0, 0)) // DEBUG\r\n\r\n        for(let i = 0; i < half.length; i++) {\r\n            if(half[i].y > average + screwHeadTolerance) {\r\n                // found start of screw head, discard rest of list\r\n                half = half.slice(0, i)\r\n                break\r\n            }\r\n        }\r\n        return half\r\n    }\r\n    tops = removeHead(tops)\r\n    bottoms = removeHead(bottoms)\r\n\r\n    // DEBUG - very important debug in fact...\r\n    /*\r\n    color = 255\r\n    for point in tops:\r\n        color -= 0.8\r\n        cv2.circle(frame, (point[0] + x, point[1] + y), 1, (0, 0, color))\r\n    color = 255\r\n    for point in bottoms:\r\n        color -= 0.8\r\n        cv2.circle(frame, (point[0] + x, point[1] + y), 1, (0, color, 0))\r\n    */\r\n    // DEBUG\r\n\r\n    // no points left on screw after cleaning, invalid screw\r\n    if(!tops.length || !bottoms.length) return [null, null]\r\n\r\n    // 6. Return tuple of cleaned tops and bottoms\r\n    return [tops, bottoms]\r\n}","// Main file handling image capture and overall procedure\r\nimport * as dp from './display'\r\nimport {minSize} from './constants'\r\nimport {getThreadCount, getLength, getDiameter} from './screwInfo'\r\nimport {cleanPoints} from './cleaner'\r\n\r\nimport {Point, Mat, Box} from './types'\r\n\r\nexport default function optiBolt(cv: any, frame: Mat) {\r\n    dp.setCV(cv)\r\n\r\n    let thresh = 80\r\n\r\n    let mask = new cv.Mat()\r\n    cv.cvtColor(frame, mask, cv.COLOR_RGBA2GRAY, 0) // to grayscale\r\n    cv.threshold(mask, mask, thresh, 255, cv.THRESH_BINARY_INV) // to binary mask\r\n\r\n    let contours = new cv.MatVector()\r\n    let hierarchy = new cv.Mat()\r\n    cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE) // grab contours\r\n\r\n    let screws = [] //create list of screws found in frame\r\n    // convert necessary data from contours into screw objects\r\n\r\n    for(let i = 0; i < contours.size(); i++) {\r\n        //let color = new cv.Scalar(255, 0, 0)\r\n        //cv.drawContours(frame, contours, i, color, 1, cv.LINE_8, hierarchy, 100)\r\n        \r\n        let ctr = contours.get(i)\r\n        \r\n        let box: Box = cv.boundingRect(ctr) // bounding box of screw\r\n        \r\n        let wB = box.width\r\n        let hB = box.height\r\n\r\n        if(wB * hB < minSize) continue // too small to be valid screw\r\n\r\n        // restructure points into list of length 2 lists (points)\r\n        let points: Point[] = []\r\n        for(let j = 0; j < ctr.rows; j++) {\r\n            points.push({\r\n                x: ctr.data32S[j*2],\r\n                y: ctr.data32S[j*2+1]\r\n            })\r\n        }\r\n        let line = new cv.Mat()\r\n        cv.fitLine(ctr, line, cv.DIST_L2, 0, 0, 0)\r\n\r\n        screws.push({points, box, line})\r\n    }\r\n    \r\n    dp.setFrame(frame) // set frame for use in display\r\n    for(let screw of screws) {\r\n        // clean up points: rotate to flat, remove head, split into top and bottom lists\r\n        let [tops, bottoms] = cleanPoints(screw, frame)\r\n\r\n        if(!tops || !bottoms) continue // invalid screw after cleaning\r\n\r\n        for(let p of tops) {\r\n            let color = new cv.Scalar(255, 0, 0)\r\n            cv.circle(frame, {x: p.x + screw.box.x, y: p.y + screw.box.y}, 0, color, 0)\r\n        }\r\n\r\n        // grab screw info\r\n        let length = getLength(tops, bottoms)\r\n        let diameter = getDiameter(tops, bottoms)\r\n        let threadCount = getThreadCount(tops, bottoms)\r\n\r\n        dp.setBox(screw.box) // set box dimensions for use in display\r\n\r\n        dp.outline() // outline the screw with rounded box\r\n        let allInfo = true\r\n        if(allInfo) {\r\n            // label all measurment info for screw\r\n            dp.labelAllInfo(length, diameter, threadCount)\r\n        } else {\r\n            // use color indicators for easy human sorting\r\n            dp.quickColorInfo(length, diameter, threadCount)\r\n        }\r\n    }\r\n\r\n    // display final image\r\n    cv.imshow('canvasOutput', frame)\r\n    cv.imshow('canvasOutput2', mask)\r\n\r\n    frame.delete()\r\n    mask.delete()\r\n    contours.delete()\r\n    hierarchy.delete()\r\n}\r\n// when exited, release the capture\r\n//cap.release()\r\n//cv.destroyAllWindows()","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n   \r\nReactDOM.render(<App/>, document.getElementById('root'));\r\nserviceWorker.unregister();"],"sourceRoot":""}