{"version":3,"sources":["App.jsx","useScript.ts","Screw.tsx","screw/constants.ts","screw/screwInfo.ts","screw/cleaner.ts","screw/optiBolt.ts","serviceWorker.ts","index.tsx"],"names":["v","width","window","innerWidth","height","innerHeight","facingMode","exact","WebcamCapture","useScript","loaded","useState","screws","setScews","webcamRef","useRef","useEffect","cv","global","video","document","getElementById","cap","VideoCapture","setInterval","Mat","frame","CV_8UC4","read","newScrews","optiBolt","style","border","id","audio","ref","screenshotFormat","videoConstraints","position","viewBox","map","screw","i","key","cachedScripts","src","error","state","setState","includes","push","script","createElement","async","onScriptLoad","onScriptError","index","indexOf","splice","remove","addEventListener","body","appendChild","removeEventListener","Screw","props","box","x","y","strokeWidth","stroke","fill","strokeDasharray","rx","h","Detail","label","value","length","color","x1","y1","x2","y2","diameter","thread","frac","cx","cy","r","LabelText","text","whole","num","den","alignmentBaseline","fontSize","pixelsPerInch","minSize","screwHeadTolerance","peakTolerance","getLength","tops","bottoms","half","getDiameter","averageHeight","average","p","getThreadCount","k","amp","heading","peaks","t","b","Math","round","cleanPoints","line","data32F","dx","dy","A","atan2","flatPoints","points","point","xRel","yRel","sqrt","aOff","xNew","cos","yNew","sin","extra","onTops","crossed","concat","highest","reverse","removeHead","slice","mask","cvtColor","COLOR_RGBA2GRAY","threshold","THRESH_BINARY_INV","contours","MatVector","hierarchy","findContours","RETR_EXTERNAL","CHAIN_APPROX_SIMPLE","size","ctr","get","boundingRect","j","rows","data32S","fitLine","DIST_L2","imperialFrac","Object","assign","delete","max","floor","left","abs","Boolean","location","hostname","match","ReactDOM","render","App","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c3e53174.chunk.js","sourcesContent":["import React, { useEffect, useRef, useState } from 'react'\r\nimport Webcam from 'react-webcam'\r\nimport useScript from './useScript'\r\nimport optiBolt from './screw/optiBolt'\r\nimport Screw from './Screw'\r\n\r\nconst v = {\r\n    width: window.innerWidth,\r\n    height: window.innerHeight,\r\n    facingMode: {exact: 'environment'}\r\n}\r\n\r\nexport default function WebcamCapture() {\r\n    const [loaded] = useScript('opencv.js')\r\n\r\n    const [screws, setScews] = useState()\r\n\r\n    const webcamRef = useRef()\r\n\r\n    useEffect(() => {\r\n        if(!loaded) return\r\n\r\n        const cv = global.cv\r\n\r\n        let video = document.getElementById('video')\r\n        let cap = new cv.VideoCapture(video)\r\n\r\n        setInterval(() => {\r\n            if(!cv.Mat) return\r\n            let frame = new cv.Mat(video.height, video.width, cv.CV_8UC4)\r\n            cap.read(frame)\r\n            let newScrews = optiBolt(cv, frame)\r\n            setScews(newScrews)\r\n        }, 10)\r\n    }, [loaded])\r\n    \r\n    return <>\r\n        <div style={{\r\n            border: 'solid red 0px',\r\n            width: '500px',\r\n            height: '360px',\r\n        }}>\r\n            <Webcam id='video'\r\n                audio={false}\r\n                ref={webcamRef}\r\n                screenshotFormat='image/jpeg'\r\n                width={v.width}\r\n                height={v.height}\r\n                videoConstraints={v}\r\n                style={{\r\n                    position: 'absolute',\r\n                    width: v.width,\r\n                    height: v.height\r\n                }}\r\n            />\r\n            <svg viewBox={`0 0 ${v.width} ${v.height}`}\r\n                style={{\r\n                    position: 'absolute',\r\n                    width: v.width,\r\n                    height: v.height\r\n                }}\r\n            >\r\n                {\r\n                    screws ? screws.map((screw, i) =>\r\n                        <Screw key={i} screw={screw}/>\r\n                    ) : null\r\n                }\r\n            </svg>\r\n        </div>\r\n    </>\r\n}","import {useState, useEffect} from 'react'\r\n\r\nlet cachedScripts: string[] = []\r\nexport default function useScript(src: string) {\r\n  // Keeping track of script loaded and error state\r\n  const [state, setState] = useState({\r\n    loaded: false,\r\n    error: false\r\n  })\r\n\r\n  useEffect(\r\n    () => {\r\n      // If cachedScripts array already includes src that means another instance ...\r\n      // ... of this hook already loaded this script, so no need to load again.\r\n      if (cachedScripts.includes(src)) {\r\n        setState({\r\n          loaded: true,\r\n          error: false\r\n        })\r\n      } else {\r\n        cachedScripts.push(src)\r\n\r\n        // Create script\r\n        let script = document.createElement('script')\r\n        script.src = src\r\n        script.async = true\r\n\r\n        // Script event listener callbacks for load and error\r\n        const onScriptLoad = () => {\r\n          setState({\r\n            loaded: true,\r\n            error: false\r\n          })\r\n        }\r\n\r\n        const onScriptError = () => {\r\n          // Remove from cachedScripts we can try loading again\r\n          const index = cachedScripts.indexOf(src)\r\n          if (index >= 0) cachedScripts.splice(index, 1)\r\n          script.remove()\r\n\r\n          setState({\r\n            loaded: true,\r\n            error: true\r\n          })\r\n        }\r\n\r\n        script.addEventListener('load', onScriptLoad)\r\n        script.addEventListener('error', onScriptError)\r\n\r\n        // Add script to document body\r\n        document.body.appendChild(script)\r\n\r\n        // Remove event listeners on cleanup\r\n        return () => {\r\n          script.removeEventListener('load', onScriptLoad)\r\n          script.removeEventListener('error', onScriptError)\r\n        }\r\n      }\r\n    },\r\n    [src] // Only re-run effect if script src changes\r\n  )\r\n\r\n  return [state.loaded, state.error]\r\n}","import React from 'react'\r\n\r\ninterface IProps {\r\n    screw: any\r\n}\r\n\r\nexport default function Screw(props: IProps) {\r\n    let {x, y, width, height} = props.screw.box\r\n    const h = 100\r\n\r\n    return <>\r\n        <rect\r\n            strokeWidth='3'\r\n            stroke='#444'\r\n            fill={'none'}\r\n            strokeDasharray='10'\r\n            rx='15'\r\n            {...props.screw.box}\r\n        />\r\n        <svg x={x + width} y={y + height / 2 - h/2}>\r\n            <rect\r\n                x='-10'\r\n                fill={'#444'}\r\n                rx='15'\r\n                width={210} //160\r\n                height={h}\r\n            />\r\n            <Detail label='Length' value={props.screw.length || {}} color='red' y={20}/>\r\n            <line x1='10' y1='35' x2='140' y2='35' stroke='#666'/>\r\n            <Detail label='Diameter' value={props.screw.diameter || {}} color='lime' y={50}/>\r\n            <line x1='10' y1='65' x2='140' y2='65' stroke='#666'/>\r\n            <Detail label='Thread' value={props.screw.thread || {}} color='blue' y={80} frac/>\r\n\r\n            <line x1='110' y1='10' x2='110' y2='90' stroke='#666'/>\r\n        </svg>\r\n    </>\r\n}\r\n\r\ninterface IDetailProps {\r\n    label: string\r\n    value: number | {whole: number, num: number, den: number}\r\n    frac?: boolean\r\n    color: string\r\n    y: number\r\n} \r\nfunction Detail(props: IDetailProps) {\r\n    return <>\r\n        <circle cx='20' cy={props.y} r='9' fill={props.color}/>\r\n        <LabelText text={props.label} x={40} y={props.y}/>\r\n        {\r\n        typeof props.value === 'number' ?\r\n            <LabelText text={props.value} x={120} y={props.y}/>\r\n            :\r\n            <LabelText text={`${props.value.whole} + ${props.value.num}/${props.value.den} in`} x={120} y={props.y}/>\r\n        }\r\n    </>\r\n}\r\n\r\nfunction LabelText(props: {text: string | number, x: number, y: number}) {\r\n    return <text x={props.x} y={props.y + 1} fill='white' alignmentBaseline='middle' fontSize='16'>\r\n        {props.text}\r\n    </text>\r\n}","// Constants used for various purposes\r\nexport const pixelsPerInch = 300 // pixels per inch\r\nexport const minSize = 0.3 * pixelsPerInch // minimum area a \"screw\" can be without being ignored\r\nexport const screwHeadTolerance = 0.06 * pixelsPerInch // tolerance for discounting screw head points\r\nexport const peakTolerance = 0.7 // tolerance for discounting noise in peak recognition\r\n\r\n// Identifiable Screw Measurements [for estimating and color indicators]\r\nexport const screwLengths = {\r\n    [3/8]: [0, 0, 255], // tiny boi -> red\r\n    [5/8]: [0, 255, 0], // normal boi -> green\r\n    [3/4]: [255, 0, 0], // funky boi -> blue\r\n    [1/1]: [255, 0, 255], // smol wood boi -> purple\r\n    [2 + 1/4]: [255, 255, 0] // absolute lad - > cyan\r\n} \r\n\r\nexport const screwDiameters = {\r\n    [3/16]: [0, 0, 255], // normal-ish chonk -> red\r\n    [1/8]: [255, 0, 0] // thin wood -> blue\r\n}\r\n\r\nexport const screwThreads = {\r\n    13: [0, 0, 255], // tiny boi -> red\r\n    17: [0, 255, 0], // normal boi AND funky boi -> green\r\n    15: [255, 0, 255], // smol wood boi -> purple\r\n    19: [255, 255, 0] // absolute lad - > cyan\r\n}","// Functions for pulling quantitative values from a cleaned set of points\r\nimport {pixelsPerInch, peakTolerance} from './constants'\r\n\r\nimport {ScrewHalf, Point} from './types'\r\n\r\nfunction getLength(tops: ScrewHalf, bottoms: ScrewHalf) {\r\n    // Returns estimated length of screw\r\n    function length(half: ScrewHalf) {\r\n        return half[half.length - 1].x - half[0].x\r\n    }\r\n    return ((length(tops) + length(bottoms)) / 2) / pixelsPerInch\r\n}\r\n\r\nfunction getDiameter(tops: ScrewHalf, bottoms: ScrewHalf) {\r\n    // Returns estimated diameter of screw\r\n    function averageHeight(half: ScrewHalf) {\r\n        let average = 0\r\n        half.map(p => average += p.y)\r\n        return average / half.length\r\n    }\r\n    return (averageHeight(tops) + averageHeight(bottoms)) / pixelsPerInch\r\n}\r\n\r\nfunction getThreadCount(tops: ScrewHalf, bottoms: ScrewHalf): number {\r\n    // Returns estimated thread count of screw\r\n    function thread(half: ScrewHalf) {\r\n        let k: Point[] = [] // DEBUG - for seeing some important points\r\n\r\n        let amp = 0 // keeps track of most extreme recent amplitude\r\n        let heading = false // boolean that alternates when a peak or valley is reached\r\n        let peaks = 0\r\n        for(let p of half) {\r\n            let height = p.y // get y coord of p\r\n            if((heading && (height - peakTolerance > amp)) || ((!heading && (height + peakTolerance < amp)))) {\r\n                // reached either a peak or valley\r\n                if(heading) {\r\n                    peaks++\r\n                    k.push(p) // peak\r\n                }\r\n                heading = !heading // invert heading boolean, going from peaks, to valleys, or vise versa\r\n            } else {\r\n                // not a peak of valley, continue searching\r\n                amp = height\r\n            }\r\n        }\r\n        return peaks\r\n    }\r\n    let t = thread(tops)\r\n    let b = thread(bottoms)\r\n    return Math.round((t + b) / 2)\r\n}\r\n\r\nexport {getLength, getDiameter, getThreadCount}","// Contains function for cleaning contour points for later processing\r\nimport {screwHeadTolerance} from './constants'\r\nimport {Screw, Point, ScrewHalf} from './types'\r\n\r\nexport function cleanPoints(screw: Screw): [ScrewHalf | null, ScrewHalf | null] {\r\n    // Function Outline:\r\n    // 1. Rotate all points of screw by opposite the angle of line of best fit (rotate points to have screw laying horizontally)\r\n    // 2. Assign each point to tops or bottoms lists, splitting screw in half\r\n    // 3. Flip x and y for necessary points so that screw head is on the right\r\n    // 4. Reverse order of necessary lists so that first element is farthest left\r\n    // 5. Find extraneous points to remove head of screw\r\n    // 6. Return tuple of cleaned tops and bottoms\r\n\r\n    let [dx, dy, x, y] = screw.line.data32F // unpack line best fit dy/dx, center at (x, y)\r\n    let A = Math.atan2(dy, dx) // rotate all points by this angle\r\n\r\n    let flatPoints: ScrewHalf = []\r\n    // 1. Rotate all points of screw by opposite the angle of line of best fit\r\n    for(let point of screw.points) {\r\n        // coords relative to center of screw at (x, y)\r\n        let xRel = x - point.x\r\n        let yRel = y - point.y\r\n\r\n        let r = Math.sqrt(xRel * xRel + yRel * yRel) // distance to point\r\n        let aOff = Math.atan2(yRel, xRel) // angle to point\r\n        \r\n        // new rotated coords\r\n        let xNew = r * Math.cos(aOff - A)\r\n        let yNew = r * Math.sin(aOff - A)\r\n\r\n        flatPoints.push({x: xNew, y: yNew}) // add to list\r\n    }\r\n\r\n    // 2. Assign each point to tops or bottoms lists, splitting screw in half\r\n    let tops: ScrewHalf = []\r\n    let bottoms: ScrewHalf = []\r\n    let extra: Point[] = [] // to be appended to beginning of either tops or bottoms\r\n\r\n    let onTops = flatPoints[0].y < 0 // whether or not on tops\r\n    let crossed = 0 // counts number of times crossed\r\n    for(let p of flatPoints) {\r\n        if((p.y < 0) !== onTops) {\r\n            // crossed\r\n            crossed++\r\n            onTops = !onTops\r\n        }\r\n        if(crossed >= 2) {\r\n            extra.push(p)\r\n        } else if(p.y < 0) {\r\n            tops.push(p)\r\n        } else {\r\n            bottoms.push(p)\r\n        }\r\n    }\r\n    // merge extra list with correct half in order\r\n    if(onTops) tops = extra.concat(tops)\r\n    else bottoms = extra.concat(bottoms)\r\n\r\n    // now for the tricky bit...\r\n\r\n    // find if highest point is to the left or right of center\r\n    let highest = {x: 0, y: 0} // coord of heighest point (on head of screw)\r\n    for(let p of bottoms) {\r\n        if(p.y > highest.y) highest = p // found new highest\r\n    }\r\n    // 3. Flip x and y for necessary points so that screw head is on the right\r\n\r\n    // y coords\r\n    for(let p of tops) p.y = -p.y // always have to negate y coord of all in tops\r\n    // never have to negate y coord of all in bottoms\r\n\r\n    // x coords\r\n    if(highest.x < 0) {\r\n        // screw head was on left\r\n        for(let p of tops) p.x = -p.x // negate x coord of all in tops\r\n        for(let p of bottoms) p.x = -p.x // negate x coord of all in bottoms\r\n        \r\n    // 4. Reverse order of necessary lists so that first element is farthest left\r\n        bottoms.reverse() // reverse list of bottoms\r\n    } else {\r\n        // screw head is on right\r\n        tops.reverse() // reverse list of tops\r\n    }\r\n\r\n    // 5. Find extraneous points to remove head of screw\r\n    function removeHead(half: ScrewHalf) {\r\n        // sub function applied to tops and bottoms\r\n        let average = 0\r\n        if(half.length === 0) return []\r\n\r\n        for(let p of half) average += p.y\r\n        average /= half.length // average is now roughly radius of screw\r\n\r\n        for(let i = 0; i < half.length; i++) {\r\n            if(half[i].y > average + screwHeadTolerance) {\r\n                // found start of screw head, discard rest of list\r\n                half = half.slice(0, i)\r\n                break\r\n            }\r\n        }\r\n        return half\r\n    }\r\n    tops = removeHead(tops)\r\n    bottoms = removeHead(bottoms)\r\n\r\n    // no points left on screw after cleaning, invalid screw\r\n    if(!tops.length || !bottoms.length) return [null, null]\r\n\r\n    // 6. Return tuple of cleaned tops and bottoms\r\n    return [tops, bottoms]\r\n}","// Main file handling image capture and overall procedure\r\nimport {minSize} from './constants'\r\nimport {getThreadCount, getLength, getDiameter} from './screwInfo'\r\nimport {cleanPoints} from './cleaner'\r\n\r\nimport {Point, Mat, Box, Screw, FracMeasure} from './types'\r\n\r\nexport default function optiBolt(cv: any, frame: Mat): Screw[] {\r\n    let thresh = 80\r\n\r\n    let mask = new cv.Mat()\r\n    cv.cvtColor(frame, mask, cv.COLOR_RGBA2GRAY, 0) // to grayscale\r\n    cv.threshold(mask, mask, thresh, 255, cv.THRESH_BINARY_INV) // to binary mask\r\n\r\n    let contours = new cv.MatVector()\r\n    let hierarchy = new cv.Mat()\r\n    cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE) // grab contours\r\n\r\n    let screws: Screw[] = [] //create list of screws found in frame\r\n    // convert necessary data from contours into screw objects\r\n\r\n    for(let i = 0; i < contours.size(); i++) {\r\n        //let color = new cv.Scalar(255, 0, 0)\r\n        //cv.drawContours(frame, contours, i, color, 1, cv.LINE_8, hierarchy, 100)\r\n        \r\n        let ctr = contours.get(i)\r\n        \r\n        let box: Box = cv.boundingRect(ctr) // bounding box of screw\r\n        \r\n        let wB = box.width\r\n        let hB = box.height\r\n\r\n        if(wB * hB < minSize) continue // too small to be valid screw\r\n\r\n        // restructure points into list of length 2 lists (points)\r\n        let points: Point[] = []\r\n        for(let j = 0; j < ctr.rows; j++) {\r\n            points.push({\r\n                x: ctr.data32S[j*2],\r\n                y: ctr.data32S[j*2+1]\r\n            })\r\n        }\r\n        let line = new cv.Mat()\r\n        cv.fitLine(ctr, line, cv.DIST_L2, 0, 0, 0)\r\n\r\n        screws.push({points, box, line})\r\n    }\r\n    \r\n    for(let screw of screws) {\r\n        // clean up points: rotate to flat, remove head, split into top and bottom lists\r\n        let [tops, bottoms] = cleanPoints(screw)\r\n\r\n        if(!tops || !bottoms) continue // invalid screw after cleaning\r\n\r\n        // grab screw info\r\n        let length = imperialFrac(getLength(tops, bottoms))\r\n        let diameter = imperialFrac(getDiameter(tops, bottoms))\r\n        let threadCount = getThreadCount(tops, bottoms)\r\n\r\n        let thread = threadCount\r\n        Object.assign(screw, {length, diameter, thread})\r\n    }\r\n\r\n    frame.delete()\r\n    mask.delete()\r\n    contours.delete()\r\n    hierarchy.delete()\r\n\r\n    return screws\r\n}\r\n// when exited, release the capture\r\n//cap.release()\r\n//cv.destroyAllWindows()\r\n\r\nexport function imperialFrac(x: number, max: number = 32): FracMeasure {\r\n    // Converts decimal into 3 part tuple for fractional imperial measurement\r\n    if(x < 0) return {whole: 0, num: 0, den: 1}//throw new Error('x must be >= 0')\r\n    \r\n    let whole = Math.floor(x)\r\n    let left = x - whole\r\n    let den = 2\r\n\r\n    while(Math.abs(Math.round(left * den) - left * den) > 0.1 && den !== max) {\r\n        den *= 2\r\n    }\r\n    let num = Math.round(left * den)\r\n\r\n    return {whole, num, den}\r\n}","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n   \r\nReactDOM.render(<App/>, document.getElementById('root'));\r\nserviceWorker.unregister();"],"sourceRoot":""}